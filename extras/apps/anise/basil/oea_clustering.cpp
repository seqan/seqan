// ==========================================================================
//                                 BASIL
// ==========================================================================
// Copyright (c) 2006-2014, Knut Reinert, FU Berlin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of Knut Reinert or the FU Berlin nor the names of
//       its contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL KNUT REINERT OR THE FU BERLIN BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
// SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
// CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGE.
//
// ==========================================================================
// Author: Manuel Holtgrewe <manuel.holtgrewe@fu-berlin.de>
// ==========================================================================

#include "oea_clustering.h"

#include <ostream>
#include <unordered_map>
#include <vector>

#include <boost/heap/fibonacci_heap.hpp>

#include <seqan/seq_io.h>

namespace  // anonymous
{

// ----------------------------------------------------------------------------
// Class OeaCluster
// ----------------------------------------------------------------------------

// Representation of one OEA cluster candidate, includes supporting ids.
//
// Generated by OeaClusterGenerator.  We need the supporting ids for the chaining/cover algorithms.

struct OeaClusterWithSupport : OeaClusterRecord
{
    std::vector<int> supportLeft;
    std::vector<int> supportRight;

    explicit
    OeaClusterWithSupport(int rID = -1, int beginPos = -1, int endPos = -1, int centerPos = -1,
                          int leftWeight = 0, int rightWeight = 0, int totalWeight = 0) :
               OeaClusterRecord(rID, beginPos, endPos, centerPos, leftWeight, rightWeight, totalWeight)
    {}
};

template <typename TStream>
TStream & operator<<(TStream & stream, OeaClusterWithSupport const & cluster)
{
    stream << "(refId=" << cluster.region.rID << ", center=" << cluster.centerPos
           << ", beginPos=" << cluster.region.beginPos << ", endPos=" << cluster.region.endPos
           << ", supportLeft.size()=" << cluster.supportLeft.size() << " [";
    std::copy(cluster.supportLeft.begin(), cluster.supportLeft.end(),
              std::ostream_iterator<int>(stream, " "));
    stream << " ], supportRight.size()="
           << cluster.supportRight.size() << " [";
    std::copy(cluster.supportRight.begin(), cluster.supportRight.end(),
              std::ostream_iterator<int>(stream, " "));
    stream << " ], totalWeight = " << cluster.totalWeight << ")";
    return stream;
}

// ----------------------------------------------------------------------------
// Class OeaClusterGenerator
// ----------------------------------------------------------------------------

// Algorithm for iterative cluster generation.

class OeaClusterGenerator
{
public:
    OeaClusterGenerator(int windowSize, int minLookAheadSpan = 0, bool debug = true) :
            currentRefId(-1), currentPos(-windowSize), windowSize(windowSize), debug(debug), totalQueueSize(0),
            totalActiveCount(0), minLookAheadSpan(minLookAheadSpan)
    {}

    void reset()
    {
        windowLeftFirst.clear();
        windowLeftCurrent.clear();
        windowLeftSecond.clear();
        windowRightFirst.clear();
        windowRightCurrent.clear();
        windowRightSecond.clear();
        lookAheadLeft.clear();
        lookAheadRight.clear();
        totalQueueSize = 0;
        totalActiveCount = 0;
        currentRefId = -1;
        currentPos = -windowSize;
    }

    void push(std::vector<OeaClusterWithSupport> & clusters, int refId, int pos, bool leftSide)
    {
        // Detect change of reference.
        if (currentRefId != refId)
        {
            finish(clusters);
            reset();
            currentRefId = refId;
        }

        // Insert the new position in the look-ahead, register with total queue size.
        if (debug)
            std::cerr << "[ INSERTING INTO LOOKAHEAD: " << pos << " left? " << leftSide << "\n";
        std::deque<int> * lookAhead = leftSide ? &lookAheadLeft : &lookAheadRight;
        std::deque<int>::iterator it = std::lower_bound(lookAhead->begin(), lookAhead->end(), pos);
        lookAhead->insert(it, pos);
        totalQueueSize += 1;
        SEQAN_ASSERT_GEQ(pos, currentPos);

        // The events for the right side are important since they become active immediately.  Also, there might be
        // multiple events at the same position.  We need to wait until we know that we can go to the next position and
        // all events that come from the look-ahead go into the second window halves and no event that could come later
        // is at the position of any even that went into one second window half.
        //
        // The rightmost position from the look-ahead must be > thresholdPos and the leftmost must be smaller than the
        // rightmost pos in the lookahead.  The righmost position in the look-ahead is a lower bound on any position
        // that comes into the look-ahead.

        while (true)
        {
            // Get position where we will move the window center to next.
            int nextPos = std::min(nextPosLeft(), nextPosRight());
            if (nextPos == seqan::maxValue<int>())
                break;  // Nothing to do, empty queues.

            int leftmostLookAhead = leftmostLookAheadPos();
            int rightmostLookAhead = rightmostLookAheadPos();

            // Break if the look-ahead was empty and we need to wait for more.
            if (leftmostLookAhead == seqan::maxValue<int>() || rightmostLookAhead == seqan::minValue<int>())
                break;

            // Break if the lookahead contains values from a single position only.  We need to wait for more since we
            // want to move all values from the same position into the second halves of the windows at once.
            if (leftmostLookAhead == rightmostLookAhead)
                break;

            // Break if the lookahead's position span is too short.
            int lookAheadSpan = rightmostLookAhead - leftmostLookAhead + 1;
            if (minLookAheadSpan > 0 && lookAheadSpan < minLookAheadSpan)
                break;

            // The rightmost value in the look-ahead must be right of the new rightmost window border.
            int thresholdPos = nextPos + windowSize;
            if (rightmostLookAhead < thresholdPos)
                break;

            // Otherwise, we now have more than one position in the look-ahead and can advance the current position to
            // the next position.
            SEQAN_ASSERT_NEQ(std::min(nextPosLeft(), nextPosRight()), seqan::maxValue<int>());
            executeOneStep(clusters);
        }
    }

    void finish(std::vector<OeaClusterWithSupport> & clusters)
    {
        // Advance to next positions until all positions have been processed.
        while (totalQueueSize > 0 && (std::min(nextPosLeft(), nextPosRight()) != seqan::maxValue<int>()))
            executeOneStep(clusters);
    }

private:

    // Advance current position by one, updating the windows and look-ahead.
    void executeOneStep(std::vector<OeaClusterWithSupport> & clusters)
    {
        SEQAN_ASSERT_NEQ(currentPos, seqan::maxValue<int>());
        int nextPos = std::min(nextPosLeft(), nextPosRight());
        SEQAN_ASSERT_NEQ(nextPos, seqan::maxValue<int>());

        if (debug)
        {
            std::cerr << ",-- BEFORE STEP\n"
                      << "|\n"
                      << "| position = " << currentPos << ", nextPos == " << nextPos << "\n"
                      << "|\n"
                      << "| first half left window\n"
                      << "|";
            for (unsigned i = 0; i < windowLeftFirst.size(); ++i)
                std::cerr << " " << windowLeftFirst[i];
            std::cerr << "\n"
                      << "| current focus left\n"
                      << "|";
            for (unsigned i = 0; i < windowLeftCurrent.size(); ++i)
                std::cerr << " " << windowLeftCurrent[i];
            std::cerr << "\n"
                      << "| second half left window\n"
                      << "|";
            for (unsigned i = 0; i < windowLeftSecond.size(); ++i)
                std::cerr << " " << windowLeftSecond[i];
            std::cerr << "\n"
                      << "| look-ahead left\n"
                      << "|";
            for (unsigned i = 0; i < lookAheadLeft.size(); ++i)
                std::cerr << " " << lookAheadLeft[i];
            std::cerr << "\n+--\n"
                      << "| first half right window\n"
                      << "|";
            for (unsigned i = 0; i < windowRightFirst.size(); ++i)
                std::cerr << " " << windowRightFirst[i];
            std::cerr << "\n"
                      << "| current focus right\n"
                      << "|";
            for (unsigned i = 0; i < windowRightCurrent.size(); ++i)
                std::cerr << " " << windowRightCurrent[i];
            std::cerr << "\n"
                      << "| second half right window\n"
                      << "|";
            for (unsigned i = 0; i < windowRightSecond.size(); ++i)
                std::cerr << " " << windowRightSecond[i];
            std::cerr << "\n"
                      << "| look-ahead right\n"
                      << "|";
            for (unsigned i = 0; i < lookAheadRight.size(); ++i)
                std::cerr << " " << lookAheadRight[i];
            std::cerr << "\n"
                      << "`--\n";
        }

        SEQAN_ASSERT_GEQ(nextPos, currentPos);

        // Append new cluster to clusters.
        if (totalActiveCount > 0)
        {
            int beginPos = seqan::maxValue<int>();
            if (!windowLeftFirst.empty())
                beginPos = std::min(beginPos, windowLeftFirst.front());
            if (!windowRightSecond.empty())
                beginPos = std::min(beginPos, windowRightSecond.front());
            int endPos = seqan::minValue<int>();
            if (!windowLeftFirst.empty())
                endPos = std::max(endPos, windowLeftFirst.back());
            if (!windowRightSecond.empty())
                endPos = std::max(endPos, windowRightSecond.back());
            if (!windowLeftCurrent.empty())
            {
                beginPos = std::min(beginPos, windowLeftCurrent.front());
                endPos = std::max(endPos, windowLeftCurrent.front());
            }
            if (!windowRightCurrent.empty())
            {
                beginPos = std::min(beginPos, windowRightCurrent.front());
                endPos = std::max(endPos, windowRightCurrent.front());
            }
            OeaClusterWithSupport cluster(currentRefId, beginPos, endPos + 1, currentPos,
                                          windowLeftFirst.size() + windowLeftCurrent.size(),
                                          windowRightCurrent.size() + windowRightSecond.size(),
                                          totalActiveCount);
            std::copy(windowLeftFirst.begin(), windowLeftFirst.end(), std::back_inserter(cluster.supportLeft));
            std::copy(windowLeftCurrent.begin(), windowLeftCurrent.end(), std::back_inserter(cluster.supportLeft));
            std::copy(windowRightCurrent.begin(), windowRightCurrent.end(), std::back_inserter(cluster.supportRight));
            std::copy(windowRightSecond.begin(), windowRightSecond.end(), std::back_inserter(cluster.supportRight));
            SEQAN_ASSERT_EQ((unsigned)cluster.totalWeight, cluster.supportLeft.size() + cluster.supportRight.size());

            clusters.push_back(cluster);
            if (debug)
                std::cerr << ",-- pushing cluster\n"
                          << "| " << cluster << "\n"
                          << "`--\n";
        }

        // We now advance the window center to nextPos.

        // Move events from look-ahead into the second window halves.
        int secondWindowHalfEndPos = nextPos + windowSize;
        while (!lookAheadLeft.empty() && lookAheadLeft.front() < secondWindowHalfEndPos)
        {
            if (debug)
                std::cerr << "MOVING FRONT FROM LEFT LOOK-AHEAD TO LEFT SECOND\n";
            moveFrontToBack(windowLeftSecond, lookAheadLeft);
        }
        while (!lookAheadRight.empty() && lookAheadRight.front() < secondWindowHalfEndPos)
        {
            if (debug)
                std::cerr << "MOVING FRONT FROM RIGHT LOOK-AHEAD TO RIGHT SECOND\n";
            moveFrontToBack(windowRightSecond, lookAheadRight);
            totalActiveCount += 1;
        }

        // Move events from the right window halves into the current window position.
        while (!windowLeftSecond.empty() && windowLeftSecond.front() + 1 == nextPos)
        {
            if (debug)
                std::cerr << "MOVING FRONT FROM LEFT SECOND TO LEFT CURRENT\n";
            moveFrontToBack(windowLeftCurrent, windowLeftSecond);
            totalActiveCount += 1;
        }
        while (!windowRightSecond.empty() && windowRightSecond.front() == nextPos)
        {
            if (debug)
                std::cerr << "MOVING FRONT FROM RIGHT SECOND TO RIGHT CURRENT\n";
            moveFrontToBack(windowRightCurrent, windowRightSecond);
        }

        // Move events from the current window position into the left window halves.
        while (!windowLeftCurrent.empty() && windowLeftCurrent.front() + 1 < nextPos)
        {
            if (debug)
                std::cerr << "MOVING FRONT FROM LEFT CURRENT TO LEFT FIRST\n";
            moveFrontToBack(windowLeftFirst, windowLeftCurrent);
        }
        while (!windowRightCurrent.empty() && windowRightCurrent.front() < nextPos)
        {
            if (debug)
                std::cerr << "MOVING FRONT FROM RIGHT CURRENT TO RIGHT FIRST\n";
            moveFrontToBack(windowRightFirst, windowRightCurrent);
            SEQAN_ASSERT_GT(totalActiveCount, 0);
            totalActiveCount -= 1;
        }

        // Kick events out of the first window halves.
        int firstWindowHalfBeginPos = nextPos - windowSize;
        while (!windowLeftFirst.empty() && windowLeftFirst.front() < firstWindowHalfBeginPos)
        {
            if (debug)
                std::cerr << "POP FRONT FROM LEFT FIRST WINDOW\n";
            windowLeftFirst.pop_front();
            SEQAN_ASSERT_GT(totalQueueSize, 0);
            totalQueueSize -= 1;
            SEQAN_ASSERT_GT(totalActiveCount, 0);
            totalActiveCount -= 1;
        }
        while (!windowRightFirst.empty() && windowRightFirst.front() < firstWindowHalfBeginPos)
        {
            if (debug)
                std::cerr << "POP FRONT FROM RIGHT FIRST WINDOW\n";
            windowRightFirst.pop_front();
            SEQAN_ASSERT_GT(totalQueueSize, 0);
            totalQueueSize -= 1;
        }

        if (debug)
        {
            std::cerr << ",-- AFTER STEP\n"
                      << "|\n"
                      << "| position = " << nextPos << "\n"
                      << "|\n"
                      << "| first half left window\n"
                      << "|";
            std::copy(windowLeftFirst.begin(), windowLeftFirst.end(), std::ostream_iterator<int>(std::cerr, " "));
            std::cerr << "\n"
                      << "| current focus left\n"
                      << "|";
            std::copy(windowLeftCurrent.begin(), windowLeftCurrent.end(), std::ostream_iterator<int>(std::cerr, " "));
            std::cerr << "\n"
                      << "| second half left window\n"
                      << "|";
            std::copy(windowLeftSecond.begin(), windowLeftSecond.end(), std::ostream_iterator<int>(std::cerr, " "));
            std::cerr << "\n"
                      << "| look-ahead left\n"
                      << "|";
            std::copy(lookAheadLeft.begin(), lookAheadLeft.end(), std::ostream_iterator<int>(std::cerr, " "));
            std::cerr << "\n+--\n"
                      << "| first half right window\n"
                      << "|";
            std::copy(windowRightFirst.begin(), windowRightFirst.end(), std::ostream_iterator<int>(std::cerr, " "));
            std::cerr << "\n"
                      << "| current focus right\n"
                      << "|";
            std::copy(windowRightCurrent.begin(), windowRightCurrent.end(), std::ostream_iterator<int>(std::cerr, " "));
            std::cerr << "\n"
                      << "| second half right window\n"
                      << "|";
            std::copy(windowRightSecond.begin(), windowRightSecond.end(), std::ostream_iterator<int>(std::cerr, " "));
            std::cerr << "\n"
                      << "| look-ahead right\n"
                      << "|";
            std::copy(lookAheadRight.begin(), lookAheadRight.end(), std::ostream_iterator<int>(std::cerr, " "));
            std::cerr << "\n"
                      << "`--\n";
        }

        currentPos = nextPos;
    }

    // Move front element of right to back of left.
    void moveFrontToBack(std::deque<int> & left, std::deque<int> & right)
    {
        SEQAN_ASSERT_NOT(right.empty());
        if (!left.empty())
            SEQAN_ASSERT_GEQ(right.front(), left.back());
        left.push_back(right.front());
        right.pop_front();
    }

    // Return next position from left events.
    int nextPosLeft() const
    {
        if (!windowLeftSecond.empty())
            return windowLeftSecond.front() + 1;
        else if (!lookAheadLeft.empty())
            return lookAheadLeft.front() + 1;
        else
            return seqan::maxValue<int>();
    }

    // Return next position from right events.
    int nextPosRight() const
    {
        if (!windowRightSecond.empty())
            return windowRightSecond.front();
        else if (!lookAheadRight.empty())
            return lookAheadRight.front();
        else
            return seqan::maxValue<int>();
    }

    int leftmostLookAheadPos() const
    {
        int leftmostLookAheadPos = seqan::maxValue<int>();
        if (!lookAheadLeft.empty())
            leftmostLookAheadPos = lookAheadLeft.front();
        if (!lookAheadRight.empty())
            leftmostLookAheadPos = std::min(leftmostLookAheadPos, lookAheadRight.front());
        return leftmostLookAheadPos;
    }

    int rightmostLookAheadPos() const
    {
        int rightmostLookAheadPos = seqan::minValue<int>();
        if (!lookAheadLeft.empty())
            rightmostLookAheadPos = lookAheadLeft.back();
        if (!lookAheadRight.empty())
            rightmostLookAheadPos = std::max(rightmostLookAheadPos, lookAheadRight.back());
        return rightmostLookAheadPos;
    }

    void clear()
    {
        currentPos = -1;
        totalQueueSize = 0;
        windowLeftFirst.clear();
        windowLeftSecond.clear();
        windowRightFirst.clear();
        windowRightSecond.clear();
        lookAheadLeft.clear();
        lookAheadRight.clear();
    }

    // The current reference id; used for flushing on reference change.
    int currentRefId;
    // The current position.
    int currentPos;
    // The width of one window half.
    int windowSize;
    // Flag enabling/disabling debug output.
    bool debug;

    // We have queues for the first and second half of the window for left and right positions.  Also, we have one queue
    // for the loook-ahead for the left and right side.
    //
    // Note that while we should actually take the end positions of alignments on the left side we do not do this since
    // the alignments are always sorted by their start position.
    //
    //
    //            current position
    // ------------------o----------------------------------------------> REF
    //
    //   | *  *       *  | o    o    oo |
    //   |   o   o   oo  | *  **   *    |
    //   '---------------+--------------'
    //
    //   [ window*First  )
    //                   [ window*Second)
    //
    // * currently active events/positions
    // o currently inactive events/positions
    //
    // Actually, windowRightFirst is not important and could be removed.  Is only there to keep the symmetry in the
    // algorithm below to make clearer what happens.

    std::deque<int> windowLeftFirst;
    std::deque<int> windowLeftCurrent;
    std::deque<int> windowLeftSecond;
    std::deque<int> windowRightFirst;
    std::deque<int> windowRightCurrent;
    std::deque<int> windowRightSecond;

    std::deque<int> lookAheadLeft;
    std::deque<int> lookAheadRight;

    // We use totalQueueSize for easy termination detection.
    int totalQueueSize;
    // The number of active elements in the window.
    int totalActiveCount;
    // The minimal span of positions that the look-ahead has to contain.  This makes sure that when positions arrive
    // only "roughly sorted" then the positions falling out of the look-ahead will still be sorted.  The "only roughly
    // sorted" property is true when considering right-ends of read alignment positions with indels and clipping where
    // the alignments are sorted by start position.
    //
    // Set to 0 to disable.
    int minLookAheadSpan;
};

// ----------------------------------------------------------------------------
// Class OeaSelectionAlgorithm
// ----------------------------------------------------------------------------

// Algorithm for iterative most parsinomous cluster selection through set cover.

class OeaSelectionAlgorithm
{
public:
    explicit
    OeaSelectionAlgorithm(bool debug = false) : debug(debug) {}

    void reset()
    {
        buffer.clear();
    }

    void push(std::vector<OeaClusterWithSupport> & result, OeaClusterWithSupport const & cluster)
    {
        // If cluster does not overlap with buffer then we can compute the solution to the set cover problem on buffer
        // and write the solution to clusters.  We can rely on this because both begin and end positions of clusters
        // pushed into the function are growing monotonically.
        if (!buffer.empty() && cluster.region.beginPos >= buffer.back().region.endPos)
            _computeSetCover(result);

        if (!buffer.empty())
        {
            // The windows pushed into the algorithm have to be sorted by begin and end position.
            SEQAN_ASSERT_GEQ(cluster.region.beginPos, buffer.back().region.beginPos);
            SEQAN_ASSERT_GEQ(cluster.region.endPos, buffer.back().region.endPos);
        }

        if (debug)
            std::cerr << "APPENDING TO BUFFER " << cluster << "\n";
        buffer.push_back(cluster);
    }

    void finish(std::vector<OeaClusterWithSupport> & result)
    {
        _computeSetCover(result);
    }

private:

    void _computeSetCover(std::vector<OeaClusterWithSupport> & result)
    {
        if (debug)
            std::cerr << "SET COVER\n";
        // TPair -- (weight, id).
        typedef std::pair<unsigned, unsigned> TPair;
        typedef boost::heap::fibonacci_heap<TPair> TPriorityQueue;
        typedef TPriorityQueue::handle_type THandle;

        // Priority queue (max-heap by default as we need it) with (weight, buffer-id) elements.  We also store the
        // handle for each element in the buffer.
        TPriorityQueue pQueue;
        std::vector<THandle> handles;
        std::vector<bool> active(buffer.size(), true);

        // Build maps "position supporting on left" => buffer, same for right.  At the same time, fill priority queue so
        // we can access the elements in buffer in the order of their weight.
        std::multimap<int, unsigned> supportedLeftBy;
        std::multimap<int, unsigned> supportedRightBy;
        for (unsigned i = 0; i < buffer.size(); ++i)
        {
            OeaClusterWithSupport const & cluster = buffer[i];
            std::transform(cluster.supportLeft.begin(), cluster.supportLeft.end(),
                           std::inserter(supportedLeftBy, supportedLeftBy.begin()),
                           [i](int idx) { return std::make_pair(idx, i); });
            std::transform(cluster.supportRight.begin(), cluster.supportRight.end(),
                           std::inserter(supportedRightBy, supportedRightBy.begin()),
                           [i](int idx) { return std::make_pair(idx, i); });
            std::pair<unsigned, unsigned> el(cluster.totalWeight, i);
            handles.push_back(pQueue.push(el));
            if (debug)
                std::cerr << "INTO QUEUE: (" << cluster.totalWeight << ", " << i << ") --> " << cluster << "\n";
        }

        // On the go, we will build sets of covered positions.
        std::set<int> supportLeftCovered;
        std::set<int> supportRightCovered;

        // Compute set cover.
        while (!pQueue.empty() && pQueue.top().first != 0u)  // While there are candidates with uncovered positions.
        {
            OeaClusterWithSupport const & cluster = buffer[pQueue.top().second];
            if (debug)
                std::cerr << "INTO RESULT " << cluster << "\n";
            result.push_back(cluster);

            // Register all positions from the left support that are covered by cluster now and are yet not clustered as
            // covered.
            for (unsigned i = 0; i < cluster.supportLeft.size(); ++i)
            {
                int pos = cluster.supportLeft[i];
                if (!supportLeftCovered.insert(pos).second)
                    continue;  // Already covered.

                typedef std::multimap<int, unsigned>::const_iterator TIter;
                std::pair<TIter, TIter> range = supportedLeftBy.equal_range(pos);
                SEQAN_ASSERT_NOT(range.first == range.second);
                for (TIter it = range.first; it != range.second; ++it)
                {
                    if (!active[it->second])
                        continue;
                    std::pair<unsigned, unsigned> el = *handles[it->second];
                    SEQAN_ASSERT_GT(el.first, 0u);
                    el.first -= 1;
                    if (debug)
                        std::cerr << "DECREASING " << buffer[it->second] << " TO " << el.first << "\n";
                    pQueue.decrease(handles[it->second], el);
                }
            }

            // Register all positions from the right support that are covered by cluster now and are yet not clustered as
            // covered.
            for (unsigned i = 0; i < cluster.supportRight.size(); ++i)
            {
                int pos = cluster.supportRight[i];
                if (!supportRightCovered.insert(pos).second)
                    continue;  // Already covered.

                typedef std::multimap<int, unsigned>::iterator TIter;
                std::pair<TIter, TIter> range = supportedRightBy.equal_range(pos);
                SEQAN_ASSERT_NOT(range.first == range.second);
                for (TIter it = range.first; it != range.second; ++it)
                {
                    if (!active[it->second])
                        continue;
                    std::pair<unsigned, unsigned> el = *handles[it->second];
                    SEQAN_ASSERT_GT(el.first, 0u);
                    el.first -= 1;
                    if (debug)
                        std::cerr << "DECREASING " << buffer[it->second] << " TO " << el.first << "\n";
                    pQueue.decrease(handles[it->second], el);
                }
            }

            active[pQueue.top().second] = false;
            pQueue.pop();
        }

        buffer.clear();
    }

    std::vector<OeaClusterWithSupport> buffer;
    bool debug;
};

// ----------------------------------------------------------------------------
// Class IntervalEvent
// ----------------------------------------------------------------------------

// One main requirement/invariant in the following is that there are no duplicate intervals.  Otherwise, the algorithm
// will not work correctly.  This invariant is fulfilled when using windows over the genome but when putting in read
// alignments, this assumption is not fulfilled.

struct IntervalEvent
{
    unsigned id;      // ID of interval.
    int pos;          // Position of event.
    bool isOpen;      // Whether this is an open or close event.
    unsigned weight;  // Weight of the interval associated with the event.

    IntervalEvent() : id(0), pos(0), isOpen(true), weight(0)
    {}

    IntervalEvent(unsigned id, int pos, bool isOpen, unsigned weight) :
            id(id), pos(pos), isOpen(isOpen), weight(weight)
    {}

    // Sort lexicographically, closing events preceding opening ones.
    bool operator<(IntervalEvent const & rhs) const
    {
        return (pos < rhs.pos) || (pos == rhs.pos && isOpen < rhs.isOpen);
    }
};

// ----------------------------------------------------------------------------
// Class Filter1DChaining
// ----------------------------------------------------------------------------

// Allows to compute a 1D chain by iteratively giving the intervals in increasing begin position.

class Filter1DChaining
{
public:
    Filter1DChaining(bool debug = false) :
            currentRId(-1), currentPos(-1), windowSize(0), lookAhead(-1), bestTotalWeight(0),
            bestId(seqan::maxValue<unsigned>()), debug(debug)
    {}

    Filter1DChaining(int windowSize, bool debug = false) :
            currentRId(-1), currentPos(-1), windowSize(windowSize), lookAhead(-1), bestTotalWeight(0),
            bestId(seqan::maxValue<unsigned>()), debug(debug)
    {}

    void reset()
    {
        currentRId = -1;
        currentPos = -1;
        lookAhead = -1;
        bestTotalWeight = 0;
        predecessor.clear();
        bestWeightForInterval.clear();
        lookAheadList.clear();
        bestId = seqan::maxValue<unsigned>();
    }

    template <typename TOutIt>
    void push(unsigned id, int rId, int beginPos, int endPos, unsigned weight, TOutIt outIt)
    {
        SEQAN_ASSERT_LEQ(beginPos, endPos);

        if (rId != currentRId)
            finish(outIt);
        currentRId = rId;

        // Insert the next interval into the lookahead list.  This will set lookAhead to the rightmost known start
        // interval begin event.
        _insertIntervalIntoLookAhead(id, beginPos, endPos, weight);

        // Now, we can process all events up to a position of (lookAhead - windowSize).
        while (currentPos < lookAhead - windowSize)
            executeOneStep(outIt);
    }

    template <typename TOutIt>
    void finish(TOutIt outIt)
    {
        while (!lookAheadList.empty())
            executeOneStep(outIt);
        reset();

        // std::cerr << ",--\n";
        // for (std::list<IntervalEvent>::const_iterator it = lookAheadList.begin(); it != lookAheadList.end(); ++it)
        //     std::cerr << "| " << *it << "\n";
        // std::cerr << "`--\n";
    }

private:
    template <typename TOutIt>
    void executeOneStep(TOutIt outIt)
    {
        if (lookAheadList.empty())  // Guard against execution with empty look-ahead.
            return;

        IntervalEvent const & event = lookAheadList.front();

        if (debug)
        {
            std::cerr << ",-- BEFORE EXECUTE ONE STEP -- lookAheadList, bestTotalWeight == " << bestTotalWeight << ", currentPos=" << currentPos << ", lookAhead=" << lookAhead << "\n";
            for (std::list<IntervalEvent>::const_iterator it = lookAheadList.begin(); it != lookAheadList.end(); ++it)
                std::cerr << "| id=" << it->id << ", pos = " << it->pos << ", isOpen = " << it->isOpen << ", weight = " << it->weight << "\n";
            std::cerr << "`--\n";
        }

        if (event.isOpen)
        {
            bestWeightForInterval[event.id] = bestTotalWeight + event.weight;
            predecessor[event.id] = bestId;
            if (debug)
                std::cerr << "bestWeightForInterval[" << event.id << "] = " << bestTotalWeight << " + " << event.weight << " == " << (bestTotalWeight + event.weight) << "\n";
        }
        else
        {
            if (bestWeightForInterval[event.id] > bestTotalWeight)
            {
                // Update best total weight and interval id.
                bestTotalWeight = bestWeightForInterval[event.id];
                if (debug)
                    std::cerr << "bestWeightForInterval[" << event.id << "] == " << bestWeightForInterval[event.id] << "\n"
                              << "predecessor[" << event.id << "] == " << bestId << "\n";

                bestId = event.id;
            }
            else if (debug)
                std::cerr << "DISCARDING " << event.id << "\t" << event.pos << "\n";

            bestWeightForInterval.erase(event.id);

            // Write out chain for current connected overlap region.
            if (bestWeightForInterval.empty())  // => no currently open interval.
            {
                std::vector<unsigned> tmp;
                for (unsigned id = bestId; id != seqan::maxValue<unsigned>(); id = predecessor[id])
                {
                    if (debug)
                        std::cerr << "SELECTING\t" << id << "\n";
                    tmp.push_back(id);
                }
                std::copy(tmp.rbegin(), tmp.rend(), outIt);

                predecessor.clear();
                bestId = seqan::maxValue<unsigned>();
            }
        }

        // Remove just processed event from look-ahead and update currentPos.
        lookAheadList.pop_front();
        currentPos = lookAheadList.empty() ? -1 : lookAheadList.front().pos;

        if (debug)
        {
            std::cerr << ",-- AFTER EXECUTE ONE STEP -- lookAheadList, bestTotalWeight == " << bestTotalWeight << ", currentPos=" << currentPos << ", lookAhead=" << lookAhead << "\n";
            for (std::list<IntervalEvent>::const_iterator it = lookAheadList.begin(); it != lookAheadList.end(); ++it)
                std::cerr << "| id=" << it->id << ", pos = " << it->pos << ", isOpen = " << it->isOpen << ", weight = " << it->weight << "\n";
            std::cerr << "`--\n";
        }
    }

    void _insertIntervalIntoLookAhead(unsigned id, int beginPos, int endPos, unsigned weight)
    {
        SEQAN_ASSERT_LEQ(lookAhead, beginPos);
        lookAhead = beginPos;

        if (debug)
            std::cerr << "INSERTING INTERVAL id=" << id << ", beginPos=" << beginPos << ", endPos=" << endPos << ", weight=" << weight << "\n";

        IntervalEvent beginEvent(id, beginPos, /*isOpen =*/true, weight);
        IntervalEvent endEvent(id, endPos, /*isOpen =*/false, weight);

        // Search in look-ahead for begin position where it fits.
        std::list<IntervalEvent>::iterator it = lookAheadList.begin();
        for (; it != lookAheadList.end() && *it < beginEvent; ++it)
            continue;
        lookAheadList.insert(it, beginEvent);
        // Search in look-ahead for end position where it fits.
        for (; it != lookAheadList.end() && *it < endEvent; ++it)
            continue;
        lookAheadList.insert(it, endEvent);
    }
    
    int currentRId;
    int currentPos;
    int windowSize;
    int lookAhead;
    std::list<IntervalEvent> lookAheadList;
    unsigned bestTotalWeight;
    unsigned bestId;
    std::unordered_map<unsigned, unsigned> predecessor;
    std::unordered_map<int, unsigned> bestWeightForInterval;
    bool debug;

    // TODO(holtgrew): Max predecessor size, weight for interval size, look ahead list size.
};

// ----------------------------------------------------------------------------
// Class OeaChainingSelectionAlgorithm
// ----------------------------------------------------------------------------

// Algorithm for iterative most parsinomous cluster selection through chaining.

class OeaChainingSelectionAlgorithm
{
public:
    explicit
    OeaChainingSelectionAlgorithm(bool debug = false) :
            chainingFilter(debug)
    {}

    void reset()
    {
        chainingFilter.reset();
    }

    void push(std::vector<OeaClusterWithSupport> & result, OeaClusterWithSupport const & cluster)
    {
        std::vector<unsigned> selectedIds;
        // TODO(holtgrew): totalWeight for cluster weight or pseudocount geometric mean?
        chainingFilter.push(buffer.size(), cluster.region.rID, cluster.region.beginPos, cluster.region.endPos,
                            cluster.totalWeight, std::back_inserter(selectedIds));
        buffer.push_back(cluster);

        for (std::vector<unsigned>::const_iterator it = selectedIds.begin(); it != selectedIds.end(); ++it)
            result.push_back(buffer[*it]);
    }

    void finish(std::vector<OeaClusterWithSupport> & result)
    {
        std::vector<unsigned> selectedIds;
        chainingFilter.finish(std::back_inserter(selectedIds));
        for (std::vector<unsigned>::const_iterator it = selectedIds.begin(); it != selectedIds.end(); ++it)
            result.push_back(buffer[*it]);
    }

private:
    std::vector<OeaClusterWithSupport> buffer;  // TODO(holtgrew): Only buffer what we need.
    Filter1DChaining chainingFilter;
};

}  // anonymous namespace

// ----------------------------------------------------------------------------
// Class OeaClusterAlgoImpl
// ----------------------------------------------------------------------------

class OeaClusterAlgoImpl
{
public:
    OeaClusterAlgoImpl(OeaClusterOptions const & options) :
            options(options), oeaClustering(options.maxFragmentSize(), options.maxFragmentSize(), options.debug)
    {}

    void push(std::vector<seqan::BamAlignmentRecord *> const & records);

    void finish();

    std::vector<OeaClusterRecord> result()
    {
        return records;
    }

private:
    // Run the cluster selection.
    void selectClusters();

    OeaClusterOptions options;
    OeaClusterGenerator oeaClustering;

    // All clusters generated so.  Cleared in finish().
    std::vector<OeaClusterWithSupport> clusters;

    // Temporary storage of records.
    //
    // TODO(holtgrew): Is this the best way to do it?
    std::vector<OeaClusterRecord> records;
};


void OeaClusterAlgoImpl::push(std::vector<seqan::BamAlignmentRecord *> const & records)
{
    for (auto ptr : records)
    {
        seqan::BamAlignmentRecord const & record = *ptr;
        SEQAN_ASSERT_EQ(options.libraryInfo.defaultOrient, BamLibraryInfo::R_PLUS);

        seqan::BamTagsDict tagsDict(const_cast<seqan::CharString &>(record.tags));  // TODO(holtgrew): ConstBamTagsDict?
        unsigned idx = 0;
        if (findTagKey(idx, tagsDict, "an"))  // Push anchors only
        {
            // The alignment is left if either the mate aligned and aligned to the right or the record aligned on the
            // forward strand.
            // TODO(holtgrew): This braks for different orientations.
            bool isLeft = (record.tLen > 0) || (!hasFlagUnmapped(record) && hasFlagNextUnmapped(record) && !hasFlagRC(record));
            oeaClustering.push(clusters, record.rID, record.beginPos, isLeft);
            if (options.debug)
                std::cerr << "Pushing OEA anchor " << record.qName << "/" << (hasFlagLast(record) + 1) << "\n";
        }
    }
}

void OeaClusterAlgoImpl::finish()
{
    oeaClustering.finish(clusters);

    // Remove OEA clusters that have too low support.
    auto itEnd = std::copy_if(clusters.begin(), clusters.end(), clusters.begin(),
                              [&](OeaClusterWithSupport const & clust)
                              {
                                  return ((int)clust.supportLeft.size() > options.oeaMinSupportEachSide &&
                                          (int)clust.supportRight.size() > options.oeaMinSupportEachSide &&
                                          (int)(clust.supportLeft.size() + clust.supportRight.size()) > options.oeaMinSupport);
                              });
    clusters.resize(itEnd - clusters.begin());

    if (options.debug)
        std::cerr << "  FILTERED CANDIDATE NUM\t" << clusters.size() << "\n";

    // Select clusters.
    std::vector<OeaClusterWithSupport> selectedClusters;
    if (options.clusterSelection == OeaClusterSelection::SET_COVER)
    {
        OeaSelectionAlgorithm clusterSelection(options.debug);  // TODO(holtgrew): Rename to something indicating set cover
        for (unsigned i = 0; i < clusters.size(); ++i)
            clusterSelection.push(selectedClusters, clusters[i]);
        clusterSelection.finish(selectedClusters);
    }
    else
    {
        OeaChainingSelectionAlgorithm clusterSelection(options.debug);
        for (unsigned i = 0; i < clusters.size(); ++i)
            clusterSelection.push(selectedClusters, clusters[i]);
        clusterSelection.finish(selectedClusters);
    }

    if (options.debug)
        std::cerr << "  CLUSTER SELECTED NUM \t" << selectedClusters.size() << "\n";

    // Write out cluster records.
    records.clear();
    std::copy(selectedClusters.begin(), selectedClusters.end(), std::back_inserter(records));

    // Cleanup.
    clusters.clear();
    clusters.shrink_to_fit();
}

// ----------------------------------------------------------------------------
// Class OeaClusterAlgo
// ----------------------------------------------------------------------------

OeaClusterAlgo::OeaClusterAlgo(OeaClusterOptions const & options) : impl(new OeaClusterAlgoImpl(options))
{}

OeaClusterAlgo::~OeaClusterAlgo()
{}

void OeaClusterAlgo::push(std::vector<seqan::BamAlignmentRecord *> const & records)
{
    impl->push(records);
}

void OeaClusterAlgo::finish()
{
    impl->finish();
}

std::vector<OeaClusterRecord> OeaClusterAlgo::result()
{
    return impl->result();
}
